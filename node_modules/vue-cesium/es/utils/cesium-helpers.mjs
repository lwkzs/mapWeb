import { compare } from 'compare-versions';
import { isEmptyObj } from './util.mjs';
import '../shared/extends/materials/index.mjs';
import { cloneDeep } from 'lodash';
import { isPlainObject, hasOwn, isArray, isFunction, isString } from '@vue/shared';
import VcCircleWaveMaterialProperty from '../shared/extends/materials/VcCircleWaveMaterialProperty.mjs';
import VcLineFlowMaterialProperty from '../shared/extends/materials/VcLineFlowMaterialProperty.mjs';
import VcLineTrailMaterialProperty from '../shared/extends/materials/VcLineTrailMaterialProperty.mjs';
import { isUndefined } from 'lodash-unified';

"use strict";
function makeCartesian2(val, isConstant = false) {
  const { Cartesian2, CallbackProperty } = Cesium;
  if (val instanceof Cesium.Cartesian2 || val instanceof CallbackProperty) {
    return val;
  }
  if (isPlainObject(val)) {
    if (hasOwn(val, "x") && hasOwn(val, "y")) {
      const value = val;
      return new Cartesian2(value.x, value.y);
    }
  }
  if (isArray(val)) {
    return new Cartesian2(val[0], val[1]);
  }
  if (isFunction(val)) {
    return new CallbackProperty(val, isConstant);
  }
  return void 0;
}
function makeCartesian3(val, ellipsoid, isConstant = false) {
  const {
    CallbackProperty,
    Cartesian3,
    Ellipsoid,
    SampledPositionProperty,
    CompositePositionProperty,
    ConstantPositionProperty,
    TimeIntervalCollectionPositionProperty
  } = Cesium;
  if (val instanceof Cartesian3 || val instanceof CallbackProperty || val instanceof SampledPositionProperty || val instanceof CompositePositionProperty || val instanceof ConstantPositionProperty || val instanceof TimeIntervalCollectionPositionProperty) {
    return val;
  }
  ellipsoid = ellipsoid || Ellipsoid.WGS84;
  if (isPlainObject(val)) {
    if (hasOwn(val, "x") && hasOwn(val, "y") && hasOwn(val, "z")) {
      const value = val;
      return new Cartesian3(value.x, value.y, value.z);
    } else if (hasOwn(val, "lng") && hasOwn(val, "lat")) {
      const value = val;
      return Cartesian3.fromDegrees(value.lng, value.lat, value.height || 0, ellipsoid);
    }
  }
  if (isArray(val)) {
    return Cartesian3.fromDegrees(val[0], val[1], val[2] || 0, ellipsoid);
  }
  if (isFunction(val)) {
    return new CallbackProperty(val, isConstant);
  }
  return void 0;
}
function makeCartesian3Array(vals, ellipsoid, isConstant = false) {
  const { CallbackProperty, Cartesian3, Ellipsoid } = Cesium;
  if (vals instanceof CallbackProperty) {
    return vals;
  }
  if (isFunction(vals)) {
    return new CallbackProperty(vals, isConstant);
  }
  ellipsoid = ellipsoid || Ellipsoid.WGS84;
  if (isArray(vals)) {
    if (isArray(vals[0]) || isPlainObject(vals[0])) {
      const results = [];
      vals.forEach((val) => {
        results.push(makeCartesian3(val, ellipsoid));
      });
      return results;
    }
    return Cartesian3.fromDegreesArrayHeights(vals, ellipsoid);
  }
  return void 0;
}
function makeCartesian2Array(vals, isConstant) {
  const { CallbackProperty } = Cesium;
  if (vals instanceof CallbackProperty) {
    return vals;
  }
  if (isFunction(vals)) {
    return new CallbackProperty(vals, isConstant);
  }
  if (isArray(vals)) {
    const points = [];
    vals.forEach((val) => {
      points.push(makeCartesian2(val));
    });
    return points;
  }
  return void 0;
}
function makeQuaternion(val, isConstant = false) {
  const { CallbackProperty, Quaternion, VelocityOrientationProperty } = Cesium;
  if (val instanceof Quaternion || val instanceof CallbackProperty || val instanceof VelocityOrientationProperty) {
    return val;
  }
  if (isPlainObject(val) && hasOwn(val, "x") && hasOwn(val, "y")) {
    const value = val;
    return new Quaternion(value.x, value.y, value.z, value.w);
  }
  if (isArray(val)) {
    return new Quaternion(val[0], val[1], val[2], val[3]);
  }
  if (isFunction(val)) {
    return new CallbackProperty(val, isConstant);
  }
  return void 0;
}
function parsePolygonHierarchyJson(val, ellipsoid) {
  val.forEach((item) => {
    item.positions = makeCartesian3Array(item.positions, ellipsoid);
    if (item.holes) {
      parsePolygonHierarchyJson(item.holes, ellipsoid);
    }
  });
}
function makePolygonHierarchy(val, ellipsoid, isConstant = false) {
  var _a;
  const { PolygonHierarchy, CallbackProperty } = Cesium;
  if (val instanceof PolygonHierarchy || val instanceof CallbackProperty) {
    return val;
  }
  if (isFunction(val)) {
    return new CallbackProperty(val, isConstant);
  }
  if (isArray(val) && val.length >= 3) {
    const points = makeCartesian3Array(val, ellipsoid);
    return new PolygonHierarchy(points);
  }
  if (isPlainObject(val) && hasOwn(val, "positions")) {
    const value = cloneDeep(val);
    value.positions = makeCartesian3Array(value.positions, ellipsoid);
    ((_a = value.holes) == null ? void 0 : _a.length) && parsePolygonHierarchyJson(value.holes, ellipsoid);
    return value;
  }
  return void 0;
}
function makeNearFarScalar(val, isConstant = false) {
  const { NearFarScalar, CallbackProperty } = Cesium;
  if (val instanceof NearFarScalar || val instanceof CallbackProperty) {
    return val;
  }
  if (isPlainObject(val) && hasOwn(val, "near") && hasOwn(val, "far")) {
    const value = val;
    return new NearFarScalar(value.near, value.nearValue || 0, value.far, value.farValue || 1);
  }
  if (isArray(val)) {
    return new NearFarScalar(val[0], val[1], val[2], val[3]);
  }
  if (isFunction(val)) {
    return new CallbackProperty(val, isConstant);
  }
  return void 0;
}
function makeDistanceDisplayCondition(val, isConstant = false) {
  const { DistanceDisplayCondition, CallbackProperty } = Cesium;
  if (val instanceof DistanceDisplayCondition || val instanceof CallbackProperty) {
    return val;
  }
  if (isPlainObject(val) && hasOwn(val, "near") && hasOwn(val, "far")) {
    const value = val;
    return new DistanceDisplayCondition(value.near, value.far);
  }
  if (isArray(val)) {
    return new DistanceDisplayCondition(val[0], val[1]);
  }
  if (isFunction(val)) {
    return new CallbackProperty(val, isConstant);
  }
  return void 0;
}
function makeColor(val, isConstant = false) {
  const { Color, CallbackProperty, defaultValue } = Cesium;
  if (val instanceof Color || val instanceof CallbackProperty) {
    return val;
  }
  if (isString(val)) {
    return Color.fromCssColorString(val);
  }
  if (isPlainObject(val)) {
    if (hasOwn(val, "red")) {
      const value = val;
      return Color.fromBytes(
        defaultValue(value.red, 255),
        defaultValue(value.green, 255),
        defaultValue(value.blue, 255),
        defaultValue(value.alpha, 255)
      );
    } else if (hasOwn(val, "x")) {
      const value = val;
      return new Color(defaultValue(value.x, 1), defaultValue(value.y, 1), defaultValue(value.z, 1), defaultValue(value.w, 1));
    }
  }
  if (isArray(val)) {
    return Color.fromBytes(val[0], val[1], val[2], defaultValue(val[3], 255));
  }
  if (isFunction(val)) {
    return new CallbackProperty(val, isConstant);
  }
  return void 0;
}
function makeColors(vals) {
  if (isArray(vals)) {
    const results = [];
    vals.forEach((val) => {
      results.push(makeColor(val));
    });
    return results;
  } else {
    return vals;
  }
}
function makeMaterialProperty(val, isConstant = false) {
  const {
    CallbackProperty,
    Color,
    CheckerboardMaterialProperty,
    ColorMaterialProperty,
    CompositeMaterialProperty,
    GridMaterialProperty,
    ImageMaterialProperty,
    MaterialProperty,
    PolylineArrowMaterialProperty,
    PolylineDashMaterialProperty,
    PolylineGlowMaterialProperty,
    PolylineOutlineMaterialProperty,
    StripeMaterialProperty,
    StripeOrientation,
    defaultValue,
    Cartesian2,
    Material
  } = Cesium;
  if (val instanceof CallbackProperty || val instanceof Color || val instanceof CheckerboardMaterialProperty || val instanceof ColorMaterialProperty || val instanceof CompositeMaterialProperty || val instanceof GridMaterialProperty || val instanceof ImageMaterialProperty || val instanceof MaterialProperty || val instanceof PolylineArrowMaterialProperty || val instanceof PolylineDashMaterialProperty || val instanceof PolylineGlowMaterialProperty || val instanceof PolylineOutlineMaterialProperty || val instanceof StripeMaterialProperty || val instanceof VcCircleWaveMaterialProperty || val instanceof VcLineFlowMaterialProperty || val instanceof VcLineTrailMaterialProperty) {
    return val;
  }
  if (isString(val) && /(.*)\.(jpg|bmp|gif|ico|pcx|jpeg|tif|png|raw|tga)$/.test(val) || val instanceof HTMLImageElement || val instanceof HTMLCanvasElement || val instanceof HTMLVideoElement) {
    return new ImageMaterialProperty({
      image: val,
      repeat: makeCartesian2({ x: 1, y: 1 }),
      color: Color.WHITE,
      transparent: true
    });
  }
  if (isArray(val) || isString(val)) {
    return new ColorMaterialProperty(makeColor(val));
  }
  if (isPlainObject(val) && hasOwn(val, "fabric")) {
    const value = val;
    switch (value.fabric.type) {
      case "Image":
        return new ImageMaterialProperty({
          image: value.fabric.uniforms.image,
          repeat: makeCartesian2(defaultValue(value.fabric.uniforms.repeat, { x: 1, y: 1 })),
          color: defaultValue(makeColor(value.fabric.uniforms.color), Color.WHITE),
          transparent: defaultValue(value.fabric.uniforms.transparent, false)
        });
      case "Color":
        return new ColorMaterialProperty(makeColor(defaultValue(value.fabric.uniforms.color, Color.WHITE)));
      case "PolylineArrow":
        return new PolylineArrowMaterialProperty(makeColor(defaultValue(value.fabric.uniforms.color, Color.WHITE)));
      case "PolylineDash":
        return new PolylineDashMaterialProperty({
          color: makeColor(defaultValue(value.fabric.uniforms.color, "white")),
          gapColor: makeColor(defaultValue(value.fabric.uniforms.gapColor, Color.TRANSPARENT)),
          dashLength: defaultValue(value.fabric.uniforms.dashLength, 16),
          dashPattern: defaultValue(value.fabric.uniforms.dashPattern, 255)
        });
      case "PolylineGlow":
        return new PolylineGlowMaterialProperty({
          color: makeColor(defaultValue(value.fabric.uniforms.color, Color.WHITE)),
          glowPower: defaultValue(value.fabric.uniforms.glowPower, 0.25),
          taperPower: defaultValue(value.fabric.uniforms.taperPower, 1)
        });
      case "PolylineOutline":
        return new PolylineOutlineMaterialProperty({
          color: makeColor(defaultValue(value.fabric.uniforms.color, Color.WHITE)),
          outlineColor: makeColor(defaultValue(value.fabric.uniforms.outlineColor, Color.BLACK)),
          outlineWidth: defaultValue(value.fabric.uniforms.outlineWidth, 1)
        });
      case "Checkerboard":
        return new CheckerboardMaterialProperty({
          evenColor: makeColor(defaultValue(value.fabric.uniforms.evenColor, Color.WHITE)),
          oddColor: makeColor(defaultValue(value.fabric.uniforms.oddColor, Color.BLACK)),
          repeat: defaultValue(makeCartesian2(value.fabric.uniforms.repeat), { x: 2, y: 2 })
        });
      case "Grid":
        return new GridMaterialProperty({
          color: makeColor(defaultValue(value.fabric.uniforms.color, Color.WHITE)),
          cellAlpha: defaultValue(value.fabric.uniforms.cellAlpha, 0.1),
          lineCount: defaultValue(makeCartesian2(value.fabric.uniforms.lineCount), { x: 8, y: 8 }),
          lineThickness: defaultValue(makeCartesian2(value.fabric.uniforms.lineThickness), { x: 1, y: 1 }),
          lineOffset: defaultValue(makeCartesian2(value.fabric.uniforms.lineOffset), { x: 0, y: 0 })
        });
      case "Stripe":
        return new StripeMaterialProperty({
          orientation: defaultValue(value.fabric.uniforms.orientation, StripeOrientation.HORIZONTAL),
          evenColor: makeColor(defaultValue(value.fabric.uniforms.evenColor, "white")),
          oddColor: makeColor(defaultValue(value.fabric.uniforms.oddColor, "black")),
          offset: defaultValue(value.fabric.uniforms.offset, 0),
          repeat: defaultValue(value.fabric.uniforms.repeat, 1)
        });
      case "VcCircleWave": {
        return new VcCircleWaveMaterialProperty({
          duration: defaultValue(value.fabric.uniforms.duration, 3e3),
          gradient: defaultValue(value.fabric.uniforms.gradient, 0.5),
          color: makeColor(defaultValue(value.fabric.uniforms.color, Color.RED)),
          count: defaultValue(value.fabric.uniforms.count, 3)
        });
      }
      case "VcLineFlow": {
        return new VcLineFlowMaterialProperty({
          image: defaultValue(value.fabric.uniforms.image, Material.DefaultImageId),
          color: makeColor(defaultValue(value.fabric.uniforms.color, new Color(1, 1, 1, 1))),
          repeat: makeCartesian2(defaultValue(value.fabric.uniforms.repeat, new Cartesian2(1, 1))),
          axisY: defaultValue(value.fabric.uniforms.axisY, false),
          mixt: defaultValue(value.fabric.uniforms.mixt, false),
          speed: defaultValue(value.fabric.uniforms.speed, 10),
          time: defaultValue(value.fabric.uniforms.time, -1)
        });
      }
      case "VcLineTrail": {
        return new VcLineTrailMaterialProperty({
          image: defaultValue(value.fabric.uniforms.image, Material.DefaultImageId),
          color: makeColor(defaultValue(value.fabric.uniforms.color, new Color(1, 0, 0, 1))),
          repeat: makeCartesian2(defaultValue(value.fabric.uniforms.repeat, new Cartesian2(1, 1))),
          axisY: defaultValue(value.fabric.uniforms.axisY, false),
          duration: defaultValue(value.fabric.uniforms.duration, 3e3),
          loop: defaultValue(value.fabric.uniforms.loop, true)
        });
      }
    }
  }
  if (isFunction(val)) {
    return new CallbackProperty(val, isConstant);
  }
  return val;
}
function makeMaterial(val) {
  var _a;
  const vcInstance = this;
  const cmpName = (_a = vcInstance == null ? void 0 : vcInstance.proxy) == null ? void 0 : _a.$options.name;
  if (cmpName && (cmpName.indexOf("Graphics") !== -1 || cmpName.indexOf("Datasource") !== -1 || cmpName === "VcOverlayDynamic" || cmpName === "VcEntity")) {
    return makeMaterialProperty(val);
  }
  const { Material, combine } = Cesium;
  if (val instanceof Material) {
    return val;
  }
  if (isPlainObject(val) && hasOwn(val, "fabric")) {
    const f = (obj) => {
      for (const i in obj) {
        if (!isArray(obj[i]) && isPlainObject(obj[i])) {
          f(obj[i]);
        } else {
          if (i.toLocaleLowerCase().indexOf("color") !== -1 && !isEmptyObj(obj[i])) {
            const result = makeColor(obj[i]);
            obj[i] = combine(result, result, true);
          }
        }
      }
    };
    f(val);
    return new Material(val);
  }
  if (isArray(val) || isString(val)) {
    const material = Material.fromType("Color");
    material.uniforms.color = makeColor(val);
    return material;
  }
  return void 0;
}
function makeAppearance(val) {
  var _a;
  const {
    Appearance,
    DebugAppearance,
    MaterialAppearance,
    PolylineColorAppearance,
    EllipsoidSurfaceAppearance,
    PerInstanceColorAppearance,
    PolylineMaterialAppearance
  } = Cesium;
  if (val instanceof Appearance || val instanceof DebugAppearance || val instanceof MaterialAppearance || val instanceof PolylineColorAppearance || val instanceof EllipsoidSurfaceAppearance || val instanceof PerInstanceColorAppearance || val instanceof PolylineMaterialAppearance) {
    return val;
  }
  if (isPlainObject(val) && hasOwn(val, "type")) {
    const options = {
      ...val.options
    };
    if ((_a = val.options) == null ? void 0 : _a.material) {
      options.material = makeMaterial.call(this, val.options.material);
    }
    return new Cesium[val.type]({
      ...options
    });
  }
  return void 0;
}
function makeRectangle(val, isConstant = false) {
  const { Rectangle, RectangleGraphics, CallbackProperty } = Cesium;
  if (val instanceof RectangleGraphics || val instanceof Rectangle || val instanceof CallbackProperty) {
    return val;
  }
  if (isArray(val)) {
    return Rectangle.fromDegrees(val[0], val[1], val[2], val[3]);
  }
  if (isPlainObject(val)) {
    if (hasOwn(val, "west")) {
      const value = val;
      return Rectangle.fromDegrees(value.west, value.south, value.east, value.north);
    } else if (hasOwn(val, "x")) {
      const value = val;
      return new Rectangle(value.x, value.y, value.z, value.w);
    }
  }
  if (isFunction(val)) {
    return new CallbackProperty(val, isConstant);
  }
  return void 0;
}
function makeBoundingRectangle(val, isConstant = false) {
  const { BoundingRectangle, CallbackProperty } = Cesium;
  if (val instanceof BoundingRectangle || val instanceof CallbackProperty) {
    return val;
  }
  if (isPlainObject(val) && hasOwn(val, "x")) {
    const value = val;
    return new BoundingRectangle(value.x, value.y, value.width, value.height);
  }
  if (isArray(val)) {
    return new BoundingRectangle(val[0], val[1], val[2], val[3]);
  }
  if (isFunction(val)) {
    return new CallbackProperty(val, isConstant);
  }
  return void 0;
}
function makePlane(val, isConstant = false) {
  const { Cartesian3, Plane, PlaneGraphics, CallbackProperty } = Cesium;
  if (val instanceof PlaneGraphics || val instanceof Plane || val instanceof CallbackProperty) {
    return val;
  }
  if (isPlainObject(val) && hasOwn(val, "normal")) {
    const value = val;
    Cartesian3.normalize(makeCartesian3(value.normal), value.normal);
    return new Plane(value.normal, value.distance);
  }
  if (isArray(val)) {
    const point3D = makeCartesian3(val[0]);
    const normalizePoint3D = Cartesian3.normalize(point3D, new Cartesian3());
    return new Plane(normalizePoint3D, val[1]);
  }
  if (isFunction(val)) {
    return new CallbackProperty(val, isConstant);
  }
  return void 0;
}
function makeTranslationRotationScale(val, isConstant = false) {
  const { TranslationRotationScale, CallbackProperty } = Cesium;
  if (val instanceof CallbackProperty || val instanceof TranslationRotationScale) {
    return val;
  }
  if (isPlainObject(val) && hasOwn(val, "translation")) {
    const value = val;
    return new TranslationRotationScale(
      makeCartesian3(value.translation),
      makeQuaternion(value.rotation),
      makeCartesian3(value.scale)
    );
  }
  if (isArray(val)) {
    return new TranslationRotationScale(
      makeCartesian3(val[0]),
      makeQuaternion(val[1]),
      makeCartesian3(val[2])
    );
  }
  if (isFunction(val)) {
    return new CallbackProperty(val, isConstant);
  }
  return val;
}
function makeOptions(val) {
  var _a;
  const vcInstance = this;
  const cmpName = (_a = vcInstance.proxy) == null ? void 0 : _a.$options.name;
  const result = {};
  switch (cmpName) {
    case "VcDatasourceGeojson":
      Object.assign(result, val);
      result && result.markerColor && (result.markerColor = makeColor(result.markerColor));
      result && result.stroke && (result.stroke = makeColor(result.stroke));
      result && result.fill && (result.fill = makeColor(result.fill));
      return result;
  }
  return val;
}
function captureScreenshot(viewer) {
  const scene = viewer.scene;
  const promise = new Promise((resolve, reject) => {
    const removeCallback = viewer.scene.postRender.addEventListener(() => {
      removeCallback();
      try {
        const cesiumCanvas = viewer.scene.canvas;
        const canvas = cesiumCanvas;
        resolve(canvas.toDataURL("image/png"));
      } catch (e) {
        reject(e);
      }
    });
  });
  scene.render(viewer.clock.currentTime);
  return promise;
}
function makeCameraOptions(camera, ellipsoid) {
  const { Math: CesiumMath, Rectangle, defaultValue } = Cesium;
  let destination = void 0;
  let orientation = {};
  if (hasOwn(camera, "position")) {
    const position = camera.position;
    destination = makeCartesian3(position, ellipsoid);
    if (hasOwn(position, "lng") && hasOwn(position, "lat") || isArray(position)) {
      orientation = {
        heading: CesiumMath.toRadians(defaultValue(camera.heading, 360)),
        pitch: CesiumMath.toRadians(defaultValue(camera.pitch, -90)),
        roll: CesiumMath.toRadians(defaultValue(camera.roll, 0))
      };
    } else {
      orientation = {
        heading: defaultValue(camera.heading, 2 * Math.PI),
        pitch: defaultValue(camera.pitch, -Math.PI / 2),
        roll: defaultValue(camera.roll, 0)
      };
    }
  } else if (hasOwn(camera, "rectangle")) {
    const rectangle = camera.rectangle;
    destination = makeRectangle(rectangle);
    Rectangle.validate(destination);
    if (hasOwn(rectangle, "west") && hasOwn(rectangle, "south") && hasOwn(rectangle, "east") && hasOwn(rectangle, "north") || isArray(rectangle)) {
      orientation = {
        heading: CesiumMath.toRadians(defaultValue(camera.heading, 360)),
        pitch: CesiumMath.toRadians(defaultValue(camera.pitch, -90)),
        roll: CesiumMath.toRadians(defaultValue(camera.roll, 0))
      };
    } else {
      orientation = {
        heading: defaultValue(camera.heading, 2 * Math.PI),
        pitch: defaultValue(camera.pitch, -Math.PI / 2),
        roll: defaultValue(camera.roll, 0)
      };
    }
  }
  return {
    destination,
    orientation
  };
}
function setViewerCamera(viewer, camera) {
  const { destination, orientation } = makeCameraOptions(camera, viewer.scene.globe.ellipsoid);
  viewer.camera.setView({
    destination,
    orientation
  });
}
function flyToCamera(viewer, cameraOpts, options) {
  const { destination, orientation } = makeCameraOptions(cameraOpts, viewer.scene.globe.ellipsoid);
  viewer.camera.flyTo({
    ...options,
    destination: (options == null ? void 0 : options.destination) || destination,
    orientation: (options == null ? void 0 : options.orientation) || orientation
  });
}
function getGeodesicDistance(start, end, ellipsoid) {
  const { EllipsoidGeodesic, Ellipsoid } = Cesium;
  ellipsoid = ellipsoid || Ellipsoid.WGS84;
  const pickedPointCartographic = ellipsoid.cartesianToCartographic(start);
  const lastPointCartographic = ellipsoid.cartesianToCartographic(end);
  const geodesic = new EllipsoidGeodesic(pickedPointCartographic, lastPointCartographic);
  return geodesic.surfaceDistance;
}
function getHeadingPitchRoll(start, end, scene, result) {
  const { Cartesian3 } = Cesium;
  if (Cartesian3.equals(start, end)) {
    return void 0;
  }
  const vector2 = Cesium.Cartesian3.subtract(end, start, new Cesium.Cartesian3());
  const normal = Cesium.Cartesian3.normalize(vector2, new Cesium.Cartesian3());
  const rotationMatrix3 = Cesium.Transforms.rotationMatrixFromPositionVelocity(start, normal, scene.globe.ellipsoid);
  const m = Cesium.Matrix4.fromRotationTranslation(rotationMatrix3, start);
  const m1 = Cesium.Transforms.eastNorthUpToFixedFrame(
    Cesium.Matrix4.getTranslation(m, new Cesium.Cartesian3()),
    Cesium.Ellipsoid.WGS84,
    new Cesium.Matrix4()
  );
  const m3 = Cesium.Matrix4.multiply(Cesium.Matrix4.inverse(m1, new Cesium.Matrix4()), m, new Cesium.Matrix4());
  const mat3 = Cesium.Matrix4.getMatrix3(m3, new Cesium.Matrix3());
  const q = Cesium.Quaternion.fromRotationMatrix(mat3);
  const hpr = Cesium.HeadingPitchRoll.fromQuaternion(q);
  return hpr;
}
function getOrientation(start, end, scene) {
  const hpr = getHeadingPitchRoll(start, end, scene);
  hpr.pitch = hpr.pitch + Math.PI / 2 + Math.PI;
  return Cesium.Transforms.headingPitchRollQuaternion(start, hpr);
}
function getPolylineSegmentEndpoint(start, heading, distance, ellipsoid) {
  const { HeadingPitchRoll, Transforms, Matrix4, Cartesian3, Cartesian4, Quaternion, Cartographic, Ellipsoid } = Cesium;
  ellipsoid = ellipsoid || Ellipsoid.WGS84;
  const hpr = new HeadingPitchRoll(heading, 0, 0);
  const scale = new Cartesian3(1, 1, 1);
  const matrix = Transforms.headingPitchRollToFixedFrame(start, hpr);
  const translation = Matrix4.getColumn(matrix, 1, new Cartesian4());
  const axis = new Cartesian3(translation.x, translation.y, translation.z);
  const quaternion = Quaternion.fromAxisAngle(axis, distance * ellipsoid.oneOverRadii.x);
  const hprMatrix = Matrix4.fromTranslationQuaternionRotationScale(Cartesian3.ZERO, quaternion, scale);
  const position = Matrix4.multiplyByPoint(hprMatrix, start, new Cartesian3());
  const startCartographic = Cartographic.fromCartesian(start, ellipsoid);
  const positionCartographic = Cartographic.fromCartesian(position, ellipsoid);
  positionCartographic.height = startCartographic.height;
  return Cartographic.toCartesian(positionCartographic, ellipsoid);
}
function calculateAreaByPostions(positions) {
  let area = 0;
  const { CoplanarPolygonGeometry, VertexFormat, defined, Cartesian3 } = Cesium;
  const geometry = CoplanarPolygonGeometry.createGeometry(
    CoplanarPolygonGeometry.fromPositions({
      positions,
      vertexFormat: VertexFormat.POSITION_ONLY
    })
  );
  if (!isUndefined(geometry) && defined(geometry)) {
    const indices = geometry.indices;
    const positionValues = geometry.attributes.position.values;
    for (let i = 0; i < indices.length; i += 3) {
      const indice0 = indices[i];
      const indice1 = indices[i + 1];
      const indice2 = indices[i + 2];
      area += triangleArea(
        Cartesian3.unpack(positionValues, 3 * indice0, {}),
        Cartesian3.unpack(positionValues, 3 * indice1, {}),
        Cartesian3.unpack(positionValues, 3 * indice2, {})
      );
    }
  }
  return area;
}
const triangleArea = (vertexA, vertexB, vertexC) => {
  const { Cartesian3 } = Cesium;
  const vectorBA = Cartesian3.subtract(vertexA, vertexB, {});
  const vectorBC = Cartesian3.subtract(vertexC, vertexB, {});
  const crossProduct = Cartesian3.cross(vectorBA, vectorBC, vectorBA);
  return 0.5 * Cartesian3.magnitude(crossProduct);
};
const restoreCursors = [];
function setViewerCursor(viewer, cursor) {
  const restoreCursor = getComputedStyle(viewer.canvas).cursor;
  restoreCursors[restoreCursors.length - 1] !== restoreCursor && restoreCursors.push(restoreCursor);
  viewer.canvas.setAttribute("style", `cursor: ${cursor}`);
}
function restoreViewerCursor(viewer, count = 1) {
  for (let i = 0; i < count; i++) {
    const cursor = restoreCursors.pop();
    viewer.canvas.setAttribute("style", `cursor: ${cursor}`);
  }
}
function makeJulianDate(val) {
  const { JulianDate } = Cesium;
  if (val instanceof JulianDate) {
    return val;
  } else if (isString(val)) {
    return Cesium.JulianDate.fromDate(new Date(val));
  } else if (val instanceof Date) {
    return Cesium.JulianDate.fromDate(val);
  }
  return Cesium.JulianDate.now();
}
function makeHeadingPitchRoll(val) {
  const { HeadingPitchRoll, Math: CesiumMath } = Cesium;
  if (val instanceof Cesium.HeadingPitchRoll) {
    return val;
  } else if (Array.isArray(val)) {
    return new HeadingPitchRoll(CesiumMath.toRadians(val[0]) || 0, CesiumMath.toRadians(val[1]) || 0, CesiumMath.toRadians(val[2]) || 0);
  } else if (isPlainObject(val)) {
    return new HeadingPitchRoll(val.heading || 0, val.pitch || 0, val.roll || 0);
  }
  return new HeadingPitchRoll();
}
function makeHeadingPitchRang(val) {
  const { HeadingPitchRange, Math: CesiumMath } = Cesium;
  if (val instanceof Cesium.HeadingPitchRange) {
    return val;
  } else if (Array.isArray(val)) {
    return new HeadingPitchRange(CesiumMath.toRadians(val[0]) || 0, CesiumMath.toRadians(val[1]) || 0, val[2] || 0);
  } else if (isPlainObject(val)) {
    return new HeadingPitchRange(val.heading || 0, val.pitch || 0, val.range || 0);
  }
  return new HeadingPitchRange();
}
function getPolylineSegmentHeading(start, end) {
  const { Cartesian3, Matrix4, Transforms, Math: CesiumMath } = Cesium;
  const cartesian3Scratch = new Cartesian3();
  const matrix4Scratch = Transforms.eastNorthUpToFixedFrame(start);
  Matrix4.inverse(matrix4Scratch, matrix4Scratch);
  Matrix4.multiplyByPoint(matrix4Scratch, end, cartesian3Scratch);
  Cartesian3.normalize(cartesian3Scratch, cartesian3Scratch);
  return CesiumMath.toDegrees(Math.atan2(cartesian3Scratch.x, cartesian3Scratch.y));
}
function getPolylineSegmentPitch(start, end) {
  const { Cartesian3, Matrix4, Transforms, Math: CesiumMath } = Cesium;
  const cartesian3Scratch = new Cartesian3();
  const matrix4Scratch = Transforms.eastNorthUpToFixedFrame(start);
  Matrix4.inverse(matrix4Scratch, matrix4Scratch);
  Matrix4.multiplyByPoint(matrix4Scratch, end, cartesian3Scratch);
  Cartesian3.normalize(cartesian3Scratch, cartesian3Scratch);
  return CesiumMath.toDegrees(Math.asin(cartesian3Scratch.z));
}
function getFirstIntersection(start, end, viewer, objectsToExclude = []) {
  const { Cartesian3, Ray, defined } = Cesium;
  const direction = Cartesian3.normalize(Cartesian3.subtract(end, start, new Cartesian3()), new Cartesian3());
  const ray = new Ray(start, direction);
  const result = viewer.scene.pickFromRay(ray, objectsToExclude);
  if (defined(result)) {
    if (defined(result.position)) {
      const intersection = result.position;
      return intersection;
    }
  }
  return void 0;
}
function heightToLevel(altitude) {
  const A = 40487.57;
  const B = 7096758e-11;
  const C = 91610.74;
  const D = -40467.74;
  return Math.round(D + (A - D) / (1 + Math.pow(altitude / C, B)));
}
function compareCesiumVersion(a, b, operator = ">=") {
  a = a || "1.6.7";
  return compare(a, b, operator);
}
function makeImageBasedLighting(options) {
  const { ImageBasedLighting, defined } = Cesium;
  if (options instanceof Cesium.ImageBasedLighting) {
    return options;
  }
  const imageBasedLighting = new ImageBasedLighting();
  if (imageBasedLighting.imageBasedLightingFactor) {
    imageBasedLighting.imageBasedLightingFactor = makeCartesian2(options.imageBasedLightingFactor);
  }
  if (imageBasedLighting.sphericalHarmonicCoefficients) {
    imageBasedLighting.sphericalHarmonicCoefficients = makeCartesian3Array(options.sphericalHarmonicCoefficients);
  }
  if (imageBasedLighting.luminanceAtZenith) {
    imageBasedLighting.luminanceAtZenith = Number(options.luminanceAtZenith);
  }
  if (defined(imageBasedLighting.specularEnvironmentMaps)) {
    imageBasedLighting.specularEnvironmentMaps = options.specularEnvironmentMaps;
  }
  return imageBasedLighting;
}

export { calculateAreaByPostions, captureScreenshot, compareCesiumVersion, flyToCamera, getFirstIntersection, getGeodesicDistance, getHeadingPitchRoll, getOrientation, getPolylineSegmentEndpoint, getPolylineSegmentHeading, getPolylineSegmentPitch, heightToLevel, makeAppearance, makeBoundingRectangle, makeCameraOptions, makeCartesian2, makeCartesian2Array, makeCartesian3, makeCartesian3Array, makeColor, makeColors, makeDistanceDisplayCondition, makeHeadingPitchRang, makeHeadingPitchRoll, makeImageBasedLighting, makeJulianDate, makeMaterial, makeMaterialProperty, makeNearFarScalar, makeOptions, makePlane, makePolygonHierarchy, makeQuaternion, makeRectangle, makeTranslationRotationScale, restoreViewerCursor, setViewerCamera, setViewerCursor };
//# sourceMappingURL=cesium-helpers.mjs.map
