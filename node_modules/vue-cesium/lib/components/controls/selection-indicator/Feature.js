'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var cesiumHelpers = require('../../../utils/cesium-helpers.js');

"use strict";
class Feature {
  constructor(options) {
    this.id = options.id || Cesium.createGuid();
  }
  static getBoundingSphere(cesiumObject, viewer) {
    var _a, _b, _c, _d;
    const { Primitive, ClassificationPrimitive, GroundPolylinePrimitive, GroundPrimitive, Polyline } = Cesium;
    let boundingSphere;
    if (cesiumObject instanceof ClassificationPrimitive || cesiumObject instanceof GroundPolylinePrimitive) {
      boundingSphere = (_b = (_a = cesiumObject._primitive) == null ? void 0 : _a._boundingSphereWC) == null ? void 0 : _b[0];
    } else if (cesiumObject instanceof Primitive) {
      boundingSphere = (_c = cesiumObject._boundingSphereWC) == null ? void 0 : _c[0];
    } else if (cesiumObject instanceof GroundPrimitive) {
      boundingSphere = (_d = cesiumObject._boundingVolumes) == null ? void 0 : _d[0];
    } else if (cesiumObject instanceof Polyline) {
      boundingSphere = cesiumObject._boundingVolumeWC;
    } else if (cesiumObject instanceof Cesium.Entity) {
      boundingSphere = new Cesium.BoundingSphere();
      viewer.dataSourceDisplay.getBoundingSphere(cesiumObject, true, boundingSphere);
    }
    return boundingSphere;
  }
  static fromPickedFeature(cesiumObject, pickedFeature, viewer, screenPosition) {
    var _a, _b, _c, _d, _e;
    const feature = new Feature({ id: cesiumObject.id });
    if (cesiumObject.position) {
      feature.position = cesiumObject.position;
    } else if (cesiumObject instanceof Cesium.Model) {
      feature.position = Cesium.Matrix4.getTranslation(cesiumObject.modelMatrix, new Cesium.Cartesian3());
    } else if (cesiumObject instanceof Cesium.Cesium3DTileset) {
      let position = pickedFeature.content.tile.boundingSphere.center;
      let positionProperty = (_a = pickedFeature == null ? void 0 : pickedFeature.getProperty) == null ? void 0 : _a.call(pickedFeature, "position");
      if (Cesium.defined(positionProperty)) {
        if (typeof positionProperty === "string") {
          positionProperty = JSON.parse(positionProperty);
        }
        position = cesiumHelpers.makeCartesian3(positionProperty);
      }
      feature.position = position;
    } else {
      feature.position = (_b = Feature.getBoundingSphere(cesiumObject, viewer)) == null ? void 0 : _b.center;
    }
    feature.cesiumObject = cesiumObject;
    feature.pickedFeature = pickedFeature;
    feature.windowPosition = screenPosition;
    feature.description = (cesiumObject == null ? void 0 : cesiumObject.description) || ((_c = cesiumObject == null ? void 0 : cesiumObject.description) == null ? void 0 : _c.getValue());
    feature.properties = (cesiumObject == null ? void 0 : cesiumObject.properties) || ((_d = cesiumObject == null ? void 0 : cesiumObject.properties) == null ? void 0 : _d.getValue()) || ((_e = cesiumObject == null ? void 0 : cesiumObject.feature) == null ? void 0 : _e.properties);
    return feature;
  }
  static fromImageryLayerFeature(imageryFeature, viewer) {
    const feature = new Feature({
      id: imageryFeature.name
    });
    feature.name = imageryFeature.name;
    feature.description = imageryFeature.description;
    feature.properties = imageryFeature.properties;
    feature.data = imageryFeature.data;
    feature.imageryLayer = imageryFeature.imageryLayer;
    feature.position = viewer.scene.globe.ellipsoid.cartographicToCartesian(imageryFeature.position);
    feature.coords = imageryFeature.coords;
    return feature;
  }
}

exports["default"] = Feature;
//# sourceMappingURL=Feature.js.map
