'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

"use strict";
let isExtended = false;
let createShadowReceiveFragmentShaderNative;
class ShadowMapShaderExtend {
  static extend(viewer) {
    if (isExtended) {
      return;
    }
    const ShadowMapShader = Cesium["ShadowMapShader"];
    createShadowReceiveFragmentShaderNative = ShadowMapShader.createShadowReceiveFragmentShader;
    ShadowMapShader.createShadowReceiveFragmentShader = function(fs, shadowMap, castShadows, isTerrain, hasTerrainNormal) {
      var _a;
      fs = createShadowReceiveFragmentShaderNative.bind(this)(fs, shadowMap, castShadows, isTerrain, hasTerrainNormal);
      const isSpotLight = shadowMap._isSpotLight;
      if (isSpotLight) {
        fs.sources[0] = `
          uniform vec4 shadowMap_viewshedVisibleColor;
          uniform vec4 shadowMap_viewshedInvisibleColor;
          ${fs.sources[0]}
        `;
        const webgl2 = (_a = viewer.scene.context) == null ? void 0 : _a.webgl2;
        fs.sources[fs.sources.length - 1] = fs.sources[fs.sources.length - 1].replace(
          `${webgl2 ? "out_FragColor" : "gl_FragColor"}.rgb *= visibility;`,
          `
          float _depth = shadowPosition.z - shadowParameters.depthBias;
          float _visibility = czm_shadowDepthCompare(shadowMap_texture, shadowPosition.xy, _depth);
          ${webgl2 ? "out_FragColor" : "gl_FragColor"}.rgb *= (_visibility < 0.999 ? shadowMap_viewshedInvisibleColor.rgb :shadowMap_viewshedVisibleColor.rgb);
          `
        );
        fs.sources[fs.sources.length - 1] = fs.sources[fs.sources.length - 1].replace(
          "vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz);",
          "vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz);if (distance(positionEC.xyz, shadowMap_lightPositionEC.xyz) > shadowMap_lightPositionEC.w) { return; }"
        );
      }
      return fs;
    };
    isExtended = true;
  }
  static revoke(viewer) {
    if (!isExtended) {
      return;
    }
    const ShadowMapShader = Cesium["ShadowMapShader"];
    ShadowMapShader.createShadowReceiveFragmentShader = createShadowReceiveFragmentShaderNative;
    isExtended = false;
  }
}

exports["default"] = ShadowMapShaderExtend;
//# sourceMappingURL=ShadowMapShaderExtend.js.map
