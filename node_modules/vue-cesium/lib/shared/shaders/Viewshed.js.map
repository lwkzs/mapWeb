{"version":3,"file":"Viewshed.js","sources":["../../../../../packages/shared/shaders/Viewshed.ts"],"sourcesContent":["/*\n * @Author: zouyaoji@https://github.com/zouyaoji\n * @Date: 2022-04-29 17:43:24\n * @LastEditTime: 2023-03-09 16:36:44\n * @LastEditors: zouyaoji 370681295@qq.com\n * @Description:\n * @FilePath: \\vue-cesium@next\\packages\\shared\\shaders\\Viewshed.ts\n */\nexport default `\n  uniform sampler2D colorTexture;\n  uniform vec4 u_color1;\n  uniform vec4 u_color2;\n  uniform float u_isShed;\n  uniform sampler2D shadowMap_depthTexture;\n  uniform mat4 shadowMap_matrix;\n  uniform vec4 shadowMap_lightPositionEC;\n  uniform vec3 shadowMap_lightDirectionEC;\n  uniform float u_radius;\n  uniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness;\n  uniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth;\n  uniform float czzj;\n  uniform float dis;\n  uniform float spzj;\n  uniform float mixNum;\n  uniform vec3 shadowMap_lightUp;\n  uniform vec3 shadowMap_lightDir;\n  uniform vec3 shadowMap_lightRight;\n  in vec2 v_textureCoordinates;\n  vec4 toEye(in vec2 uv, in float depth){\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n    vec4 posInCamera = czm_inverseProjection * vec4(xy, depth, 1.0);\n    posInCamera =posInCamera / posInCamera.w;\n    return posInCamera;\n  }\n  float getDepth(in vec4 depth){\n    float z_window = czm_unpackDepth(depth);\n    z_window = czm_reverseLogDepth(z_window);\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n  }\n  float _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){\n    return texture(shadowMap, uv).r;\n  }\n  float _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){\n    return step(depth, _czm_sampleShadowMap(shadowMap, uv));\n  }\n  float _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){\n    float depthBias = shadowParameters.depthBias;\n    float depth = shadowParameters.depth;\n    float nDotL = shadowParameters.nDotL;\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\n    float darkness = shadowParameters.darkness;\n    vec2 uv = shadowParameters.texCoords;\n    depth -= depthBias;\n    vec2 texelStepSize = shadowParameters.texelStepSize;\n    float radius = 1.0;\n    float dx0 = -texelStepSize.x * radius;\n    float dy0 = -texelStepSize.y * radius;\n    float dx1 = texelStepSize.x * radius;\n    float dy1 = texelStepSize.y * radius;\n    float visibility =\n    (\n    _czm_shadowDepthCompare(shadowMap, uv, depth)\n    +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\n    ) * (1.0 / 9.0)\n    ;\n    return visibility;\n  }\n  vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){\n    vec3 v01 = point -planeOrigin;\n    float d = dot(planeNormal, v01) ;\n    return (point - planeNormal * d);\n  }\n  float ptm(vec3 pt){\n    return sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);\n  }\n  void main()\n  {\n    const float PI = 3.141592653589793;\n    vec4 color = texture(colorTexture, v_textureCoordinates);\n    out_FragColor = color;\n    if ( u_isShed < 0.5 )\n        return;\n    vec4 currD = texture(czm_globeDepthTexture, v_textureCoordinates);\n    if( currD.r >= 1.0 )\n        return;\n\n    float depth = getDepth(currD);\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\n    vec3 normalEC = vec3(1.0);\n    czm_shadowParameters shadowParameters;\n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;\n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;\n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;\n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;\n    shadowParameters.depthBias *= max(depth * 0.01, 1.0);\n    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz);\n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0);\n    vec4 shadowPosition = shadowMap_matrix * positionEC;\n    shadowPosition /= shadowPosition.w;\n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0))))\n      return;\n\n    vec4 lw = czm_inverseView* vec4(shadowMap_lightPositionEC.xyz, 1.0);\n    vec4 vw = czm_inverseView* vec4(positionEC.xyz, 1.0);\n    if(distance(lw.xyz,vw.xyz)> u_radius)\n        return;\n\n    shadowParameters.texCoords = shadowPosition.xy;\n    shadowParameters.depth = shadowPosition.z;\n    shadowParameters.nDotL = nDotL;\n    float visibility = _czm_shadowVisibility(shadowMap_depthTexture, shadowParameters);\n    if(visibility > 0.3 ){\n      out_FragColor = mix(color,vec4(u_color1.rgb, 1.0),mixNum);\n    }\n    else{\n      if(abs(shadowPosition.z-0.0)<0.01){\n        return;\n      }\n      out_FragColor = mix(color,vec4(u_color2.rgb, 1.0),mixNum);\n    }\n  }\n`\n"],"names":[],"mappings":";;;;;AAQA,qBAAe,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAA;;;;"}